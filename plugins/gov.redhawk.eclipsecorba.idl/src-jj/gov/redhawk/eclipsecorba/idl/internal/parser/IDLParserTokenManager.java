/* IDLParserTokenManager.java */
/* Generated By:JavaCC: Do not edit this line. IDLParserTokenManager.java */
package gov.redhawk.eclipsecorba.idl.internal.parser;

import java.io.*;
import java.util.*;
import gov.redhawk.eclipsecorba.idl.*;
import gov.redhawk.eclipsecorba.idl.expressions.*;
import gov.redhawk.eclipsecorba.idl.types.*;
import gov.redhawk.eclipsecorba.idl.types.Enumeration;
import gov.redhawk.eclipsecorba.idl.operations.*;
import org.eclipse.emf.ecore.resource.Resource;

/** Token Manager. */
@SuppressWarnings("unused")
public class IDLParserTokenManager implements IDLParserConstants {
	private final List<Comment> comments = new ArrayList<Comment>();

	private final List<String> includes = new ArrayList<String>();

	private String prefix;
	private Scope currentScope;

	private BlockComment lastBlock;

	BlockComment popComment() {
		BlockComment retVal = lastBlock;
		if (lastBlock != null) {
			lastBlock = null;
		}
		return retVal;
	}

	String getPrefix() {
		return prefix;
	}

	List<Comment> getComments() {
		return comments;
	}

	List<String> getIncludes() {
		return includes;
	}

	void clearComments() {
		comments.clear();
		lastBlock = null;
	}

	void setCurrentScope(Scope scope) {
		currentScope = scope;
	}

	private void CommonTokenAction(Token token) {
		// lastBlock = null;
		if (token.specialToken != null) {
			Token special = token.specialToken;
			while (special.specialToken != null)
				special = special.specialToken;
			// The above line walks back the special token chain until it
			// reaches the first special token after the previous regular
			// token.
			while (special != null) {
				// Now walk down the tree handling each special token
				switch (special.kind) {
				case SINGLE_LINE_COMMENT: {
					LineComment comment = IdlFactory.eINSTANCE.createLineComment();
					comment.setStartLine(special.beginLine);
					comment.setEndLine(special.endLine);
					comment.setStartColumn(special.beginColumn);
					comment.setEndColumn(special.endColumn);
					comment.setContent(special.image.substring(2));
					comments.add(comment);
					break;
				}
				case MULTI_LINE_COMMENT: {
					lastBlock = IdlFactory.eINSTANCE.createBlockComment();
					lastBlock.setStartLine(special.beginLine);
					lastBlock.setEndLine(special.endLine);
					lastBlock.setStartColumn(special.beginColumn);
					lastBlock.setEndColumn(special.endColumn);
					lastBlock.setContent(special.image.substring(2, special.image.length() - 2));
					comments.add(lastBlock);
					break;
				}
				case PREPROCESSOR_OUTPUT: {
					if (special.image.startsWith("#pragma")) {
						String[] array = special.image.split(" ");
						if (array.length == 3) {
							if (array[1].equals("prefix")) {
								this.prefix = array[2].replace("\u005c"", "").trim();
							}
						}
						if (array.length == 4 && currentScope != null) {
							Identifiable identifiable = currentScope.findIdentifiableNull(array[2]);

							if (identifiable instanceof Definition) {
								Definition def = (Definition) identifiable;
								if (array[1].equalsIgnoreCase("ID")) {
									def.setFullId(array[3].replace("\u005c"", "").trim());
								}
								if (array[1].equalsIgnoreCase("VERSION")) {
									def.setVersion(array[3].replace("\u005c"", "").trim());
								}
							}
						}
					}
					break;
				}
				}
				special = special.next;
			}
		}
	}

	/** Debug output. */
	public java.io.PrintStream debugStream = System.out;

	/** Set debug output. */
	public void setDebugStream(java.io.PrintStream ds) {
		debugStream = ds;
	}

	private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1) {
		switch (pos) {
		case 0:
			if ((active0 & 0x100L) != 0L || (active1 & 0x20000000L) != 0L)
				return 5;
			if ((active0 & 0xfffffffffffff800L) != 0L || (active1 & 0xfffL) != 0L) {
				jjmatchedKind = 100;
				return 12;
			}
			return -1;
		case 1:
			if ((active0 & 0x42000L) != 0L || (active1 & 0x80L) != 0L)
				return 12;
			if ((active0 & 0xfffffffffffbd800L) != 0L || (active1 & 0xf7fL) != 0L) {
				if (jjmatchedPos != 1) {
					jjmatchedKind = 100;
					jjmatchedPos = 1;
				}
				return 12;
			}
			return -1;
		case 2:
			if ((active0 & 0x4000000000010000L) != 0L)
				return 12;
			if ((active0 & 0xbffffffffffef800L) != 0L || (active1 & 0xf7fL) != 0L) {
				jjmatchedKind = 100;
				jjmatchedPos = 2;
				return 12;
			}
			return -1;
		case 3:
			if ((active0 & 0x2800201090400000L) != 0L || (active1 & 0x200L) != 0L)
				return 12;
			if ((active0 & 0x97ffdfef6fbef800L) != 0L || (active1 & 0xd7fL) != 0L) {
				jjmatchedKind = 100;
				jjmatchedPos = 3;
				return 12;
			}
			return -1;
		case 4:
			if ((active0 & 0x97e61ecf6f3cd800L) != 0L || (active1 & 0xd7eL) != 0L) {
				jjmatchedKind = 100;
				jjmatchedPos = 4;
				return 12;
			}
			if ((active0 & 0x19c12000822000L) != 0L || (active1 & 0x1L) != 0L)
				return 12;
			return -1;
		case 5:
			if ((active0 & 0x16200c0222080000L) != 0L || (active1 & 0x454L) != 0L)
				return 12;
			if ((active0 & 0x81c612cd4d34d800L) != 0L || (active1 & 0x92aL) != 0L) {
				jjmatchedKind = 100;
				jjmatchedPos = 5;
				return 12;
			}
			return -1;
		case 6:
			if ((active0 & 0x80000104100000L) != 0L || (active1 & 0x922L) != 0L)
				return 12;
			if ((active0 & 0x814612cc4924d800L) != 0L || (active1 & 0x8L) != 0L) {
				jjmatchedKind = 100;
				jjmatchedPos = 6;
				return 12;
			}
			return -1;
		case 7:
			if ((active0 & 0x142028049249000L) != 0L || (active1 & 0x8L) != 0L) {
				jjmatchedKind = 100;
				jjmatchedPos = 7;
				return 12;
			}
			if ((active0 & 0x8004104c00004800L) != 0L)
				return 12;
			return -1;
		case 8:
			if ((active0 & 0x142028009241000L) != 0L)
				return 12;
			if ((active0 & 0x40008000L) != 0L || (active1 & 0x8L) != 0L) {
				jjmatchedKind = 100;
				jjmatchedPos = 8;
				return 12;
			}
			return -1;
		case 9:
			if ((active0 & 0x40000000L) != 0L || (active1 & 0x8L) != 0L)
				return 12;
			if ((active0 & 0x8000L) != 0L) {
				jjmatchedKind = 100;
				jjmatchedPos = 9;
				return 12;
			}
			return -1;
		default:
			return -1;
		}
	}

	private final int jjStartNfa_0(int pos, long active0, long active1) {
		return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1), pos + 1);
	}

	private int jjStopAtPos(int pos, int kind) {
		jjmatchedKind = kind;
		jjmatchedPos = pos;
		return pos + 1;
	}

	private int jjMoveStringLiteralDfa0_0() {
		switch (curChar) {
		case 37:
			return jjStopAtPos(0, 94);
		case 38:
			return jjStopAtPos(0, 87);
		case 40:
			return jjStopAtPos(0, 82);
		case 41:
			return jjStopAtPos(0, 83);
		case 42:
			return jjStopAtPos(0, 92);
		case 43:
			return jjStopAtPos(0, 90);
		case 44:
			return jjStopAtPos(0, 80);
		case 45:
			return jjStopAtPos(0, 91);
		case 47:
			jjmatchedKind = 93;
			return jjMoveStringLiteralDfa1_0(0x100L, 0x0L);
		case 58:
			jjmatchedKind = 79;
			return jjMoveStringLiteralDfa1_0(0x0L, 0x20000L);
		case 59:
			return jjStopAtPos(0, 76);
		case 60:
			jjmatchedKind = 96;
			return jjMoveStringLiteralDfa1_0(0x0L, 0x2000000L);
		case 61:
			return jjStopAtPos(0, 84);
		case 62:
			jjmatchedKind = 97;
			return jjMoveStringLiteralDfa1_0(0x0L, 0x1000000L);
		case 70:
			return jjMoveStringLiteralDfa1_0(0x2000000000L, 0x0L);
		case 79:
			return jjMoveStringLiteralDfa1_0(0x0L, 0x400L);
		case 84:
			return jjMoveStringLiteralDfa1_0(0x0L, 0x200L);
		case 86:
			return jjMoveStringLiteralDfa1_0(0x2000000000000L, 0x0L);
		case 91:
			return jjStopAtPos(0, 98);
		case 93:
			return jjStopAtPos(0, 99);
		case 94:
			return jjStopAtPos(0, 86);
		case 97:
			return jjMoveStringLiteralDfa1_0(0x210800L, 0x0L);
		case 98:
			return jjMoveStringLiteralDfa1_0(0x4000000L, 0x0L);
		case 99:
			return jjMoveStringLiteralDfa1_0(0x1084421080000000L, 0x0L);
		case 100:
			return jjMoveStringLiteralDfa1_0(0x0L, 0x42L);
		case 101:
			return jjMoveStringLiteralDfa1_0(0x8421000L, 0x0L);
		case 102:
			return jjMoveStringLiteralDfa1_0(0x8840100000000L, 0x0L);
		case 103:
			return jjMoveStringLiteralDfa1_0(0x100000000000000L, 0x0L);
		case 104:
			return jjMoveStringLiteralDfa1_0(0x2000000000000000L, 0x0L);
		case 105:
			return jjMoveStringLiteralDfa1_0(0x42000L, 0x84L);
		case 108:
			return jjMoveStringLiteralDfa1_0(0x10800000L, 0x0L);
		case 109:
			return jjMoveStringLiteralDfa1_0(0x4200000000L, 0x800L);
		case 110:
			return jjMoveStringLiteralDfa1_0(0x80000000000L, 0x0L);
		case 111:
			return jjMoveStringLiteralDfa1_0(0x4210000000000000L, 0x0L);
		case 112:
			return jjMoveStringLiteralDfa1_0(0x1084000L, 0x108L);
		case 114:
			return jjMoveStringLiteralDfa1_0(0x420000000L, 0x0L);
		case 115:
			return jjMoveStringLiteralDfa1_0(0x8421108000000000L, 0x10L);
		case 116:
			return jjMoveStringLiteralDfa1_0(0x42108000L, 0x0L);
		case 117:
			return jjMoveStringLiteralDfa1_0(0x210800000000L, 0x0L);
		case 118:
			return jjMoveStringLiteralDfa1_0(0x840000000000000L, 0x0L);
		case 119:
			return jjMoveStringLiteralDfa1_0(0x0L, 0x21L);
		case 123:
			return jjStopAtPos(0, 77);
		case 124:
			return jjStopAtPos(0, 85);
		case 125:
			return jjStopAtPos(0, 78);
		case 126:
			return jjStopAtPos(0, 95);
		default:
			return jjMoveNfa_0(0, 0);
		}
	}

	private int jjMoveStringLiteralDfa1_0(long active0, long active1) {
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(0, active0, active1);
			return 1;
		}
		switch (curChar) {
		case 42:
			if ((active0 & 0x100L) != 0L)
				return jjStopAtPos(1, 8);
			break;
		case 58:
			if ((active1 & 0x20000L) != 0L)
				return jjStopAtPos(1, 81);
			break;
		case 60:
			if ((active1 & 0x2000000L) != 0L)
				return jjStopAtPos(1, 89);
			break;
		case 62:
			if ((active1 & 0x1000000L) != 0L)
				return jjStopAtPos(1, 88);
			break;
		case 65:
			return jjMoveStringLiteralDfa2_0(active0, 0x2000000000L, active1, 0L);
		case 82:
			return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x200L);
		case 97:
			return jjMoveStringLiteralDfa2_0(active0, 0x420801a0000000L, active1, 0x800L);
		case 98:
			return jjMoveStringLiteralDfa2_0(active0, 0x800L, active1, 0x400L);
		case 99:
			return jjMoveStringLiteralDfa2_0(active0, 0x10000000000000L, active1, 0x1L);
		case 101:
			return jjMoveStringLiteralDfa2_0(active0, 0x100108400000000L, active1, 0x2L);
		case 104:
			return jjMoveStringLiteralDfa2_0(active0, 0x1001000000000L, active1, 0L);
		case 105:
			return jjMoveStringLiteralDfa2_0(active0, 0x840000000000L, active1, 0L);
		case 108:
			return jjMoveStringLiteralDfa2_0(active0, 0x8000000000000L, active1, 0L);
		case 109:
			return jjMoveStringLiteralDfa2_0(active0, 0x20000L, active1, 0x4L);
		case 110:
			if ((active1 & 0x80L) != 0L) {
				jjmatchedKind = 71;
				jjmatchedPos = 1;
			}
			return jjMoveStringLiteralDfa2_0(active0, 0x200010800452000L, active1, 0L);
		case 111:
			return jjMoveStringLiteralDfa2_0(active0, 0x2884420214800000L, active1, 0x40L);
		case 114:
			return jjMoveStringLiteralDfa2_0(active0, 0xc000L, active1, 0x108L);
		case 115:
			return jjMoveStringLiteralDfa2_0(active0, 0x200000000000L, active1, 0x20L);
		case 116:
			return jjMoveStringLiteralDfa2_0(active0, 0x420000000200000L, active1, 0L);
		case 117:
			return jjMoveStringLiteralDfa2_0(active0, 0xd000004001080000L, active1, 0L);
		case 118:
			return jjMoveStringLiteralDfa2_0(active0, 0x8000000L, active1, 0L);
		case 119:
			return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x10L);
		case 120:
			return jjMoveStringLiteralDfa2_0(active0, 0x1000L, active1, 0L);
		case 121:
			return jjMoveStringLiteralDfa2_0(active0, 0x42100000L, active1, 0L);
		default:
			break;
		}
		return jjStartNfa_0(0, active0, active1);
	}

	private int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1) {
		if (((active0 &= old0) | (active1 &= old1)) == 0L)
			return jjStartNfa_0(0, old0, old1);
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(1, active0, active1);
			return 2;
		}
		switch (curChar) {
		case 76:
			return jjMoveStringLiteralDfa3_0(active0, 0x2000000000L, active1, 0L);
		case 85:
			return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x200L);
		case 97:
			return jjMoveStringLiteralDfa3_0(active0, 0x1400000000L, active1, 0L);
		case 98:
			return jjMoveStringLiteralDfa3_0(active0, 0x1080000L, active1, 0L);
		case 99:
			return jjMoveStringLiteralDfa3_0(active0, 0x100801000L, active1, 0L);
		case 100:
			return jjMoveStringLiteralDfa3_0(active0, 0x200000000L, active1, 0L);
		case 101:
			return jjMoveStringLiteralDfa3_0(active0, 0x200200008000000L, active1, 0L);
		case 102:
			return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x2L);
		case 104:
			return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x1L);
		case 105:
			return jjMoveStringLiteralDfa3_0(active0, 0x800010020020000L, active1, 0x118L);
		case 106:
			return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x400L);
		case 108:
			return jjMoveStringLiteralDfa3_0(active0, 0x42004000000000L, active1, 0L);
		case 109:
			return jjMoveStringLiteralDfa3_0(active0, 0x2000020000000000L, active1, 0L);
		case 110:
			return jjMoveStringLiteralDfa3_0(active0, 0x84440010000000L, active1, 0x800L);
		case 111:
			return jjMoveStringLiteralDfa3_0(active0, 0x9000004006000L, active1, 0L);
		case 112:
			return jjMoveStringLiteralDfa3_0(active0, 0x8000000042100000L, active1, 0x4L);
		case 113:
			return jjMoveStringLiteralDfa3_0(active0, 0x100000000000L, active1, 0L);
		case 114:
			return jjMoveStringLiteralDfa3_0(active0, 0x420000000000000L, active1, 0L);
		case 115:
			return jjMoveStringLiteralDfa3_0(active0, 0x1000000880000800L, active1, 0L);
		case 116:
			if ((active0 & 0x4000000000000000L) != 0L)
				return jjStartNfaWithStates_0(2, 62, 12);
			return jjMoveStringLiteralDfa3_0(active0, 0x110088000240000L, active1, 0x20L);
		case 117:
			return jjMoveStringLiteralDfa3_0(active0, 0x408000L, active1, 0x40L);
		case 120:
			return jjMoveStringLiteralDfa3_0(active0, 0x800000000000L, active1, 0L);
		case 121:
			if ((active0 & 0x10000L) != 0L)
				return jjStartNfaWithStates_0(2, 16, 12);
			break;
		default:
			break;
		}
		return jjStartNfa_0(1, active0, active1);
	}

	private int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1) {
		if (((active0 &= old0) | (active1 &= old1)) == 0L)
			return jjStartNfa_0(1, old0, old1);
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(2, active0, active1);
			return 3;
		}
		switch (curChar) {
		case 69:
			if ((active1 & 0x200L) != 0L)
				return jjStartNfaWithStates_0(3, 73, 12);
			break;
		case 83:
			return jjMoveStringLiteralDfa4_0(active0, 0x2000000000L, active1, 0L);
		case 97:
			return jjMoveStringLiteralDfa4_0(active0, 0x8000000800000L, active1, 0x803L);
		case 98:
			return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x40L);
		case 100:
			if ((active0 & 0x800000000000000L) != 0L)
				return jjStartNfaWithStates_0(3, 59, 12);
			return jjMoveStringLiteralDfa4_0(active0, 0x40400000000L, active1, 0L);
		case 101:
			if ((active0 & 0x80000000L) != 0L)
				return jjStartNfaWithStates_0(3, 31, 12);
			else if ((active0 & 0x2000000000000000L) != 0L)
				return jjStartNfaWithStates_0(3, 61, 12);
			return jjMoveStringLiteralDfa4_0(active0, 0x10800042141000L, active1, 0x400L);
		case 103:
			if ((active0 & 0x10000000L) != 0L)
				return jjStartNfaWithStates_0(3, 28, 12);
			break;
		case 105:
			return jjMoveStringLiteralDfa4_0(active0, 0x20080800000000L, active1, 0L);
		case 108:
			return jjMoveStringLiteralDfa4_0(active0, 0x5080000L, active1, 0L);
		case 109:
			if ((active0 & 0x400000L) != 0L)
				return jjStartNfaWithStates_0(3, 22, 12);
			return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x8L);
		case 110:
			return jjMoveStringLiteralDfa4_0(active0, 0x8008000L, active1, 0L);
		case 111:
			return jjMoveStringLiteralDfa4_0(active0, 0x10000000000L, active1, 0x4L);
		case 112:
			return jjMoveStringLiteralDfa4_0(active0, 0x8000020000000000L, active1, 0L);
		case 114:
			if ((active0 & 0x1000000000L) != 0L)
				return jjStartNfaWithStates_0(3, 36, 12);
			return jjMoveStringLiteralDfa4_0(active0, 0x101008000200000L, active1, 0x20L);
		case 115:
			if ((active0 & 0x200000000000L) != 0L)
				return jjStartNfaWithStates_0(3, 45, 12);
			return jjMoveStringLiteralDfa4_0(active0, 0x4400020000000L, active1, 0L);
		case 116:
			return jjMoveStringLiteralDfa4_0(active0, 0x1080004100020800L, active1, 0x10L);
		case 117:
			return jjMoveStringLiteralDfa4_0(active0, 0x442100200002000L, active1, 0L);
		case 118:
			return jjMoveStringLiteralDfa4_0(active0, 0x4000L, active1, 0x100L);
		case 119:
			return jjMoveStringLiteralDfa4_0(active0, 0x200000000000000L, active1, 0L);
		default:
			break;
		}
		return jjStartNfa_0(2, active0, active1);
	}

	private int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1) {
		if (((active0 &= old0) | (active1 &= old1)) == 0L)
			return jjStartNfa_0(2, old0, old1);
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(3, active0, active1);
			return 4;
		}
		switch (curChar) {
		case 69:
			if ((active0 & 0x2000000000L) != 0L)
				return jjStartNfaWithStates_0(4, 37, 12);
			break;
		case 97:
			return jjMoveStringLiteralDfa5_0(active0, 0x300008000000000L, active1, 0x108L);
		case 99:
			return jjMoveStringLiteralDfa5_0(active0, 0x400000000008000L, active1, 0x410L);
		case 100:
			if ((active0 & 0x800000000000L) != 0L)
				return jjStartNfaWithStates_0(4, 47, 12);
			return jjMoveStringLiteralDfa5_0(active0, 0x100000L, active1, 0L);
		case 101:
			return jjMoveStringLiteralDfa5_0(active0, 0xc2140024000000L, active1, 0L);
		case 103:
			return jjMoveStringLiteralDfa5_0(active0, 0x800000000L, active1, 0x800L);
		case 105:
			return jjMoveStringLiteralDfa5_0(active0, 0x4003284000L, active1, 0x20L);
		case 108:
			if ((active0 & 0x800000L) != 0L)
				return jjStartNfaWithStates_0(4, 23, 12);
			return jjMoveStringLiteralDfa5_0(active0, 0x200000000L, active1, 0x40L);
		case 110:
			if ((active0 & 0x10000000000L) != 0L)
				return jjStartNfaWithStates_0(4, 40, 12);
			return jjMoveStringLiteralDfa5_0(active0, 0x20000000000000L, active1, 0L);
		case 111:
			return jjMoveStringLiteralDfa5_0(active0, 0x9000020500000000L, active1, 0L);
		case 112:
			return jjMoveStringLiteralDfa5_0(active0, 0x40001000L, active1, 0L);
		case 114:
			if ((active1 & 0x1L) != 0L)
				return jjStartNfaWithStates_0(4, 64, 12);
			return jjMoveStringLiteralDfa5_0(active0, 0x40800L, active1, 0x4L);
		case 115:
			if ((active0 & 0x20000L) != 0L)
				return jjStartNfaWithStates_0(4, 17, 12);
			break;
		case 116:
			if ((active0 & 0x2000L) != 0L)
				return jjStartNfaWithStates_0(4, 13, 12);
			else if ((active0 & 0x400000000000L) != 0L)
				return jjStartNfaWithStates_0(4, 46, 12);
			else if ((active0 & 0x1000000000000L) != 0L)
				return jjStartNfaWithStates_0(4, 48, 12);
			else if ((active0 & 0x8000000000000L) != 0L)
				return jjStartNfaWithStates_0(4, 51, 12);
			else if ((active0 & 0x10000000000000L) != 0L)
				return jjStartNfaWithStates_0(4, 52, 12);
			return jjMoveStringLiteralDfa5_0(active0, 0x8000000L, active1, 0L);
		case 117:
			return jjMoveStringLiteralDfa5_0(active0, 0x4000000000000L, active1, 0x2L);
		case 118:
			return jjMoveStringLiteralDfa5_0(active0, 0x80000000000L, active1, 0L);
		default:
			break;
		}
		return jjStartNfa_0(3, active0, active1);
	}

	private int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1) {
		if (((active0 &= old0) | (active1 &= old1)) == 0L)
			return jjStartNfa_0(3, old0, old1);
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(4, active0, active1);
			return 5;
		}
		switch (curChar) {
		case 66:
			return jjMoveStringLiteralDfa6_0(active0, 0x2000000000000L, active1, 0L);
		case 97:
			return jjMoveStringLiteralDfa6_0(active0, 0x4008800L, active1, 0L);
		case 98:
			return jjMoveStringLiteralDfa6_0(active0, 0x200000L, active1, 0L);
		case 99:
			if ((active0 & 0x80000L) != 0L)
				return jjStartNfaWithStates_0(5, 19, 12);
			break;
		case 100:
			if ((active0 & 0x2000000L) != 0L)
				return jjStartNfaWithStates_0(5, 25, 12);
			return jjMoveStringLiteralDfa6_0(active0, 0x4000L, active1, 0L);
		case 101:
			if ((active0 & 0x200000000L) != 0L)
				return jjStartNfaWithStates_0(5, 33, 12);
			else if ((active0 & 0x80000000000L) != 0L)
				return jjStartNfaWithStates_0(5, 43, 12);
			else if ((active1 & 0x40L) != 0L)
				return jjStartNfaWithStates_0(5, 70, 12);
			return jjMoveStringLiteralDfa6_0(active0, 0x100000L, active1, 0x800L);
		case 102:
			return jjMoveStringLiteralDfa6_0(active0, 0x40000L, active1, 0L);
		case 103:
			if ((active0 & 0x20000000000000L) != 0L)
				return jjStartNfaWithStates_0(5, 53, 12);
			break;
		case 104:
			if ((active1 & 0x10L) != 0L)
				return jjStartNfaWithStates_0(5, 68, 12);
			break;
		case 105:
			return jjMoveStringLiteralDfa6_0(active0, 0x100008000000000L, active1, 0L);
		case 108:
			return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x2L);
		case 109:
			if ((active0 & 0x1000000000000000L) != 0L)
				return jjStartNfaWithStates_0(5, 60, 12);
			return jjMoveStringLiteralDfa6_0(active0, 0x4000000000000L, active1, 0L);
		case 110:
			return jjMoveStringLiteralDfa6_0(active0, 0x120c00000000L, active1, 0x20L);
		case 112:
			return jjMoveStringLiteralDfa6_0(active0, 0x4000000000L, active1, 0L);
		case 114:
			if ((active0 & 0x40000000000L) != 0L)
				return jjStartNfaWithStates_0(5, 42, 12);
			return jjMoveStringLiteralDfa6_0(active0, 0x8000000140000000L, active1, 0x8L);
		case 115:
			if ((active0 & 0x20000000L) != 0L)
				return jjStartNfaWithStates_0(5, 29, 12);
			return jjMoveStringLiteralDfa6_0(active0, 0x1000000L, active1, 0L);
		case 116:
			if ((active0 & 0x400000000000000L) != 0L)
				return jjStartNfaWithStates_0(5, 58, 12);
			else if ((active1 & 0x4L) != 0L)
				return jjStartNfaWithStates_0(5, 66, 12);
			else if ((active1 & 0x400L) != 0L)
				return jjStartNfaWithStates_0(5, 74, 12);
			return jjMoveStringLiteralDfa6_0(active0, 0x40000008001000L, active1, 0x100L);
		case 120:
			return jjMoveStringLiteralDfa6_0(active0, 0x80000000000000L, active1, 0L);
		case 121:
			if ((active0 & 0x200000000000000L) != 0L)
				return jjStartNfaWithStates_0(5, 57, 12);
			break;
		default:
			break;
		}
		return jjStartNfa_0(4, active0, active1);
	}

	private int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1) {
		if (((active0 &= old0) | (active1 &= old1)) == 0L)
			return jjStartNfa_0(4, old0, old1);
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(5, active0, active1);
			return 6;
		}
		switch (curChar) {
		case 97:
			return jjMoveStringLiteralDfa7_0(active0, 0x2000000040000L, active1, 0L);
		case 99:
			return jjMoveStringLiteralDfa7_0(active0, 0x100000000800L, active1, 0L);
		case 101:
			if ((active1 & 0x100L) != 0L)
				return jjStartNfaWithStates_0(6, 72, 12);
			return jjMoveStringLiteralDfa7_0(active0, 0x4020840004000L, active1, 0L);
		case 102:
			if ((active0 & 0x100000L) != 0L)
				return jjStartNfaWithStates_0(6, 20, 12);
			break;
		case 103:
			if ((active1 & 0x20L) != 0L)
				return jjStartNfaWithStates_0(6, 69, 12);
			break;
		case 104:
			return jjMoveStringLiteralDfa7_0(active0, 0x1000000L, active1, 0L);
		case 105:
			return jjMoveStringLiteralDfa7_0(active0, 0x1000L, active1, 0L);
		case 108:
			return jjMoveStringLiteralDfa7_0(active0, 0x4400000000L, active1, 0L);
		case 110:
			if ((active0 & 0x4000000L) != 0L)
				return jjStartNfaWithStates_0(6, 26, 12);
			break;
		case 115:
			if ((active1 & 0x800L) != 0L)
				return jjStartNfaWithStates_0(6, 75, 12);
			return jjMoveStringLiteralDfa7_0(active0, 0x100008000000000L, active1, 0L);
		case 116:
			if ((active0 & 0x80000000000000L) != 0L)
				return jjStartNfaWithStates_0(6, 55, 12);
			else if ((active1 & 0x2L) != 0L)
				return jjStartNfaWithStates_0(6, 65, 12);
			return jjMoveStringLiteralDfa7_0(active0, 0x8000000000008000L, active1, 0L);
		case 117:
			return jjMoveStringLiteralDfa7_0(active0, 0x200000L, active1, 0L);
		case 121:
			if ((active0 & 0x100000000L) != 0L)
				return jjStartNfaWithStates_0(6, 32, 12);
			return jjMoveStringLiteralDfa7_0(active0, 0x40000008000000L, active1, 0x8L);
		default:
			break;
		}
		return jjStartNfa_0(5, active0, active1);
	}

	private int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1) {
		if (((active0 &= old0) | (active1 &= old1)) == 0L)
			return jjStartNfa_0(5, old0, old1);
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(6, active0, active1);
			return 7;
		}
		switch (curChar) {
		case 97:
			return jjMoveStringLiteralDfa8_0(active0, 0x8000L, active1, 0L);
		case 99:
			return jjMoveStringLiteralDfa8_0(active0, 0x40000L, active1, 0L);
		case 100:
			if ((active0 & 0x800000000L) != 0L)
				return jjStartNfaWithStates_0(7, 35, 12);
			break;
		case 101:
			if ((active0 & 0x4000000000L) != 0L)
				return jjStartNfaWithStates_0(7, 38, 12);
			else if ((active0 & 0x100000000000L) != 0L)
				return jjStartNfaWithStates_0(7, 44, 12);
			return jjMoveStringLiteralDfa8_0(active0, 0x100008001000000L, active1, 0L);
		case 102:
			return jjMoveStringLiteralDfa8_0(active0, 0x40000000L, active1, 0L);
		case 107:
			return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x8L);
		case 110:
			return jjMoveStringLiteralDfa8_0(active0, 0x20000000000L, active1, 0L);
		case 111:
			return jjMoveStringLiteralDfa8_0(active0, 0x1000L, active1, 0L);
		case 112:
			return jjMoveStringLiteralDfa8_0(active0, 0x40000008000000L, active1, 0L);
		case 115:
			if ((active0 & 0x4000L) != 0L)
				return jjStartNfaWithStates_0(7, 14, 12);
			else if ((active0 & 0x4000000000000L) != 0L)
				return jjStartNfaWithStates_0(7, 50, 12);
			else if ((active0 & 0x8000000000000000L) != 0L)
				return jjStartNfaWithStates_0(7, 63, 12);
			return jjMoveStringLiteralDfa8_0(active0, 0x2000000000000L, active1, 0L);
		case 116:
			if ((active0 & 0x800L) != 0L)
				return jjStartNfaWithStates_0(7, 11, 12);
			return jjMoveStringLiteralDfa8_0(active0, 0x200000L, active1, 0L);
		case 121:
			if ((active0 & 0x400000000L) != 0L)
				return jjStartNfaWithStates_0(7, 34, 12);
			break;
		default:
			break;
		}
		return jjStartNfa_0(6, active0, active1);
	}

	private int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1) {
		if (((active0 &= old0) | (active1 &= old1)) == 0L)
			return jjStartNfa_0(6, old0, old1);
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(7, active0, active1);
			return 8;
		}
		switch (curChar) {
		case 98:
			return jjMoveStringLiteralDfa9_0(active0, 0x8000L, active1, 0L);
		case 101:
			if ((active0 & 0x40000L) != 0L)
				return jjStartNfaWithStates_0(8, 18, 12);
			else if ((active0 & 0x200000L) != 0L)
				return jjStartNfaWithStates_0(8, 21, 12);
			else if ((active0 & 0x8000000L) != 0L)
				return jjStartNfaWithStates_0(8, 27, 12);
			else if ((active0 & 0x2000000000000L) != 0L)
				return jjStartNfaWithStates_0(8, 49, 12);
			else if ((active0 & 0x40000000000000L) != 0L)
				return jjStartNfaWithStates_0(8, 54, 12);
			return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x8L);
		case 105:
			return jjMoveStringLiteralDfa9_0(active0, 0x40000000L, active1, 0L);
		case 110:
			if ((active0 & 0x1000L) != 0L)
				return jjStartNfaWithStates_0(8, 12, 12);
			break;
		case 115:
			if ((active0 & 0x1000000L) != 0L)
				return jjStartNfaWithStates_0(8, 24, 12);
			else if ((active0 & 0x8000000000L) != 0L)
				return jjStartNfaWithStates_0(8, 39, 12);
			else if ((active0 & 0x100000000000000L) != 0L)
				return jjStartNfaWithStates_0(8, 56, 12);
			break;
		case 116:
			if ((active0 & 0x20000000000L) != 0L)
				return jjStartNfaWithStates_0(8, 41, 12);
			break;
		default:
			break;
		}
		return jjStartNfa_0(7, active0, active1);
	}

	private int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1) {
		if (((active0 &= old0) | (active1 &= old1)) == 0L)
			return jjStartNfa_0(7, old0, old1);
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(8, active0, active1);
			return 9;
		}
		switch (curChar) {
		case 108:
			return jjMoveStringLiteralDfa10_0(active0, 0x8000L, active1, 0L);
		case 120:
			if ((active0 & 0x40000000L) != 0L)
				return jjStartNfaWithStates_0(9, 30, 12);
			break;
		case 121:
			if ((active1 & 0x8L) != 0L)
				return jjStartNfaWithStates_0(9, 67, 12);
			break;
		default:
			break;
		}
		return jjStartNfa_0(8, active0, active1);
	}

	private int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1) {
		if (((active0 &= old0) | (active1 &= old1)) == 0L)
			return jjStartNfa_0(8, old0, old1);
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(9, active0, 0L);
			return 10;
		}
		switch (curChar) {
		case 101:
			if ((active0 & 0x8000L) != 0L)
				return jjStartNfaWithStates_0(10, 15, 12);
			break;
		default:
			break;
		}
		return jjStartNfa_0(9, active0, 0L);
	}

	private int jjStartNfaWithStates_0(int pos, int kind, int state) {
		jjmatchedKind = kind;
		jjmatchedPos = pos;
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			return pos + 1;
		}
		return jjMoveNfa_0(state, pos + 1);
	}

	static final long[] jjbitVec0 = { 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL };
	static final long[] jjbitVec2 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };

	private int jjMoveNfa_0(int startState, int curPos) {
		int startsAt = 0;
		jjnewStateCnt = 98;
		int i = 1;
		jjstateSet[0] = startState;
		int kind = 0x7fffffff;
		for (;;) {
			if (++jjround == 0x7fffffff)
				ReInitRounds();
			if (curChar < 64) {
				long l = 1L << curChar;
				do {
					switch (jjstateSet[--i]) {
					case 0:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddStates(0, 5);
						} else if (curChar == 34) {
							jjCheckNAddStates(6, 8);
						} else if (curChar == 39) {
							jjAddStates(9, 10);
						} else if (curChar == 46) {
							jjCheckNAdd(17);
						} else if (curChar == 47)
							jjstateSet[jjnewStateCnt++] = 5;
						else if (curChar == 35) {
							if (kind > 6)
								kind = 6;
							{
								jjCheckNAddStates(11, 13);
							}
						}
						if ((0x3fe000000000000L & l) != 0L) {
							if (kind > 102)
								kind = 102;
							{
								jjCheckNAddStates(14, 18);
							}
						} else if (curChar == 48) {
							jjAddStates(19, 20);
						}
						if (curChar == 48) {
							if (kind > 101)
								kind = 101;
							{
								jjCheckNAddTwoStates(14, 15);
							}
						}
						break;
					case 1:
						if ((0xffffffffffffdbffL & l) == 0L)
							break;
						if (kind > 6)
							kind = 6;
						{
							jjCheckNAddStates(11, 13);
						}
						break;
					case 2:
						if ((0x2400L & l) != 0L && kind > 6)
							kind = 6;
						break;
					case 3:
						if (curChar == 10 && kind > 6)
							kind = 6;
						break;
					case 4:
						if (curChar == 13)
							jjstateSet[jjnewStateCnt++] = 3;
						break;
					case 5:
						if (curChar != 47)
							break;
						if (kind > 7)
							kind = 7;
						{
							jjCheckNAddStates(21, 23);
						}
						break;
					case 6:
						if ((0xffffffffffffdbffL & l) == 0L)
							break;
						if (kind > 7)
							kind = 7;
						{
							jjCheckNAddStates(21, 23);
						}
						break;
					case 7:
						if ((0x2400L & l) != 0L && kind > 7)
							kind = 7;
						break;
					case 8:
						if (curChar == 10 && kind > 7)
							kind = 7;
						break;
					case 9:
						if (curChar == 13)
							jjstateSet[jjnewStateCnt++] = 8;
						break;
					case 10:
						if (curChar == 47)
							jjstateSet[jjnewStateCnt++] = 5;
						break;
					case 12:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 100)
							kind = 100;
						jjstateSet[jjnewStateCnt++] = 12;
						break;
					case 13:
						if (curChar != 48)
							break;
						if (kind > 101)
							kind = 101;
						{
							jjCheckNAddTwoStates(14, 15);
						}
						break;
					case 14:
						if ((0xff000000000000L & l) == 0L)
							break;
						if (kind > 101)
							kind = 101;
						{
							jjCheckNAddTwoStates(14, 15);
						}
						break;
					case 16:
						if (curChar == 46) {
							jjCheckNAdd(17);
						}
						break;
					case 17:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 105)
							kind = 105;
						{
							jjCheckNAddStates(24, 26);
						}
						break;
					case 19:
						if ((0x280000000000L & l) != 0L) {
							jjCheckNAdd(20);
						}
						break;
					case 20:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 105)
							kind = 105;
						{
							jjCheckNAddTwoStates(20, 21);
						}
						break;
					case 22:
						if (curChar == 39) {
							jjAddStates(9, 10);
						}
						break;
					case 23:
						if ((0xffffff7fffffdbffL & l) != 0L) {
							jjCheckNAdd(24);
						}
						break;
					case 24:
						if (curChar == 39 && kind > 107)
							kind = 107;
						break;
					case 26:
						if ((0x8000008400000000L & l) != 0L) {
							jjCheckNAdd(24);
						}
						break;
					case 27:
						if (curChar == 48) {
							jjCheckNAddTwoStates(28, 24);
						}
						break;
					case 28:
						if ((0xff000000000000L & l) != 0L) {
							jjCheckNAddTwoStates(28, 24);
						}
						break;
					case 29:
						if ((0x3fe000000000000L & l) != 0L) {
							jjCheckNAddTwoStates(30, 24);
						}
						break;
					case 30:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddTwoStates(30, 24);
						}
						break;
					case 31:
						if (curChar == 48) {
							jjAddStates(27, 28);
						}
						break;
					case 33:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddTwoStates(33, 24);
						}
						break;
					case 35:
						if (curChar == 34) {
							jjCheckNAddStates(6, 8);
						}
						break;
					case 36:
						if ((0xfffffffbffffdbffL & l) != 0L) {
							jjCheckNAddStates(6, 8);
						}
						break;
					case 38:
						if ((0x8000008400000000L & l) != 0L) {
							jjCheckNAddStates(6, 8);
						}
						break;
					case 39:
						if (curChar == 34 && kind > 109)
							kind = 109;
						break;
					case 40:
						if (curChar == 48) {
							jjCheckNAddStates(29, 32);
						}
						break;
					case 41:
						if ((0xff000000000000L & l) != 0L) {
							jjCheckNAddStates(29, 32);
						}
						break;
					case 42:
						if ((0x3fe000000000000L & l) != 0L) {
							jjCheckNAddStates(33, 36);
						}
						break;
					case 43:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddStates(33, 36);
						}
						break;
					case 44:
						if (curChar == 48) {
							jjAddStates(37, 38);
						}
						break;
					case 46:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddStates(39, 42);
						}
						break;
					case 48:
						if (curChar == 48) {
							jjAddStates(19, 20);
						}
						break;
					case 50:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 104)
							kind = 104;
						{
							jjAddStates(43, 44);
						}
						break;
					case 53:
						if ((0x3fe000000000000L & l) == 0L)
							break;
						if (kind > 102)
							kind = 102;
						{
							jjCheckNAddStates(14, 18);
						}
						break;
					case 54:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 102)
							kind = 102;
						{
							jjCheckNAddTwoStates(54, 55);
						}
						break;
					case 56:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddStates(45, 47);
						}
						break;
					case 57:
						if (curChar == 46)
							jjstateSet[jjnewStateCnt++] = 58;
						break;
					case 58:
						if ((0x3fe000000000000L & l) != 0L) {
							jjCheckNAddTwoStates(59, 60);
						}
						break;
					case 59:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddTwoStates(59, 60);
						}
						break;
					case 61:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddStates(0, 5);
						}
						break;
					case 62:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddTwoStates(62, 63);
						}
						break;
					case 63:
						if (curChar != 46)
							break;
						if (kind > 105)
							kind = 105;
						{
							jjCheckNAddStates(48, 50);
						}
						break;
					case 64:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 105)
							kind = 105;
						{
							jjCheckNAddStates(48, 50);
						}
						break;
					case 65:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddTwoStates(65, 16);
						}
						break;
					case 66:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddTwoStates(66, 67);
						}
						break;
					case 68:
						if ((0x280000000000L & l) != 0L) {
							jjCheckNAdd(69);
						}
						break;
					case 69:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 106)
							kind = 106;
						{
							jjCheckNAddTwoStates(69, 70);
						}
						break;
					case 72:
						if (curChar == 39) {
							jjAddStates(51, 52);
						}
						break;
					case 73:
						if ((0xffffff7fffffdbffL & l) != 0L) {
							jjCheckNAdd(74);
						}
						break;
					case 74:
						if (curChar == 39 && kind > 108)
							kind = 108;
						break;
					case 76:
						if ((0x8000008400000000L & l) != 0L) {
							jjCheckNAdd(74);
						}
						break;
					case 77:
						if (curChar == 48) {
							jjCheckNAddTwoStates(78, 74);
						}
						break;
					case 78:
						if ((0xff000000000000L & l) != 0L) {
							jjCheckNAddTwoStates(78, 74);
						}
						break;
					case 79:
						if ((0x3fe000000000000L & l) != 0L) {
							jjCheckNAddTwoStates(80, 74);
						}
						break;
					case 80:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddTwoStates(80, 74);
						}
						break;
					case 81:
						if (curChar == 48) {
							jjAddStates(53, 54);
						}
						break;
					case 83:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddTwoStates(83, 74);
						}
						break;
					case 85:
						if (curChar == 34) {
							jjCheckNAddStates(55, 57);
						}
						break;
					case 86:
						if ((0xfffffffbffffdbffL & l) != 0L) {
							jjCheckNAddStates(55, 57);
						}
						break;
					case 88:
						if ((0x8000008400000000L & l) != 0L) {
							jjCheckNAddStates(55, 57);
						}
						break;
					case 89:
						if (curChar == 34 && kind > 110)
							kind = 110;
						break;
					case 90:
						if (curChar == 48) {
							jjCheckNAddStates(58, 61);
						}
						break;
					case 91:
						if ((0xff000000000000L & l) != 0L) {
							jjCheckNAddStates(58, 61);
						}
						break;
					case 92:
						if ((0x3fe000000000000L & l) != 0L) {
							jjCheckNAddStates(62, 65);
						}
						break;
					case 93:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddStates(62, 65);
						}
						break;
					case 94:
						if (curChar == 48) {
							jjAddStates(66, 67);
						}
						break;
					case 96:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddStates(68, 71);
						}
						break;
					default:
						break;
					}
				} while (i != startsAt);
			} else if (curChar < 128) {
				long l = 1L << (curChar & 077);
				do {
					switch (jjstateSet[--i]) {
					case 0:
						if ((0x7fffffe87fffffeL & l) != 0L) {
							if (kind > 100)
								kind = 100;
							{
								jjCheckNAdd(12);
							}
						}
						if (curChar == 76) {
							jjAddStates(72, 73);
						}
						break;
					case 1:
						if (kind > 6)
							kind = 6;
						{
							jjAddStates(11, 13);
						}
						break;
					case 6:
						if (kind > 7)
							kind = 7;
						{
							jjAddStates(21, 23);
						}
						break;
					case 11:
					case 12:
						if ((0x7fffffe87fffffeL & l) == 0L)
							break;
						if (kind > 100)
							kind = 100;
						{
							jjCheckNAdd(12);
						}
						break;
					case 15:
						if ((0x20100000201000L & l) != 0L && kind > 101)
							kind = 101;
						break;
					case 18:
						if ((0x2000000020L & l) != 0L) {
							jjAddStates(74, 75);
						}
						break;
					case 21:
						if ((0x104000001040L & l) != 0L && kind > 105)
							kind = 105;
						break;
					case 23:
						if ((0xffffffffefffffffL & l) != 0L) {
							jjCheckNAdd(24);
						}
						break;
					case 25:
						if (curChar == 92) {
							jjAddStates(76, 79);
						}
						break;
					case 26:
						if ((0x54404610000000L & l) != 0L) {
							jjCheckNAdd(24);
						}
						break;
					case 32:
						if (curChar == 120) {
							jjCheckNAdd(33);
						}
						break;
					case 33:
						if ((0x7e0000007eL & l) != 0L) {
							jjCheckNAddTwoStates(33, 24);
						}
						break;
					case 34:
						if (curChar == 88) {
							jjCheckNAdd(33);
						}
						break;
					case 36:
						if ((0xffffffffefffffffL & l) != 0L) {
							jjCheckNAddStates(6, 8);
						}
						break;
					case 37:
						if (curChar == 92) {
							jjAddStates(80, 83);
						}
						break;
					case 38:
						if ((0x54404610000000L & l) != 0L) {
							jjCheckNAddStates(6, 8);
						}
						break;
					case 45:
						if (curChar == 120) {
							jjCheckNAdd(46);
						}
						break;
					case 46:
						if ((0x7e0000007eL & l) != 0L) {
							jjCheckNAddStates(39, 42);
						}
						break;
					case 47:
						if (curChar == 88) {
							jjCheckNAdd(46);
						}
						break;
					case 49:
						if (curChar == 120) {
							jjCheckNAdd(50);
						}
						break;
					case 50:
						if ((0x7e0000007eL & l) == 0L)
							break;
						if (kind > 104)
							kind = 104;
						{
							jjCheckNAddTwoStates(50, 51);
						}
						break;
					case 51:
						if ((0x20100000201000L & l) != 0L && kind > 104)
							kind = 104;
						break;
					case 52:
						if (curChar == 88) {
							jjCheckNAdd(50);
						}
						break;
					case 55:
						if ((0x20100000201000L & l) != 0L && kind > 102)
							kind = 102;
						break;
					case 60:
						if ((0x1000000010L & l) != 0L && kind > 103)
							kind = 103;
						break;
					case 67:
						if ((0x2000000020L & l) != 0L) {
							jjAddStates(84, 85);
						}
						break;
					case 70:
						if ((0x104000001040L & l) != 0L && kind > 106)
							kind = 106;
						break;
					case 71:
						if (curChar == 76) {
							jjAddStates(72, 73);
						}
						break;
					case 73:
						if ((0xffffffffefffffffL & l) != 0L) {
							jjCheckNAdd(74);
						}
						break;
					case 75:
						if (curChar == 92) {
							jjAddStates(86, 89);
						}
						break;
					case 76:
						if ((0x54404610000000L & l) != 0L) {
							jjCheckNAdd(74);
						}
						break;
					case 82:
						if (curChar == 120) {
							jjCheckNAdd(83);
						}
						break;
					case 83:
						if ((0x7e0000007eL & l) != 0L) {
							jjCheckNAddTwoStates(83, 74);
						}
						break;
					case 84:
						if (curChar == 88) {
							jjCheckNAdd(83);
						}
						break;
					case 86:
						if ((0xffffffffefffffffL & l) != 0L) {
							jjCheckNAddStates(55, 57);
						}
						break;
					case 87:
						if (curChar == 92) {
							jjAddStates(90, 93);
						}
						break;
					case 88:
						if ((0x54404610000000L & l) != 0L) {
							jjCheckNAddStates(55, 57);
						}
						break;
					case 95:
						if (curChar == 120) {
							jjCheckNAdd(96);
						}
						break;
					case 96:
						if ((0x7e0000007eL & l) != 0L) {
							jjCheckNAddStates(68, 71);
						}
						break;
					case 97:
						if (curChar == 88) {
							jjCheckNAdd(96);
						}
						break;
					default:
						break;
					}
				} while (i != startsAt);
			} else {
				int hiByte = (curChar >> 8);
				int i1 = hiByte >> 6;
				long l1 = 1L << (hiByte & 077);
				int i2 = (curChar & 0xff) >> 6;
				long l2 = 1L << (curChar & 077);
				do {
					switch (jjstateSet[--i]) {
					case 1:
						if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
							break;
						if (kind > 6)
							kind = 6;
						{
							jjAddStates(11, 13);
						}
						break;
					case 6:
						if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
							break;
						if (kind > 7)
							kind = 7;
						{
							jjAddStates(21, 23);
						}
						break;
					case 23:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 24;
						break;
					case 36:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2)) {
							jjAddStates(6, 8);
						}
						break;
					case 73:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 74;
						break;
					case 86:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2)) {
							jjAddStates(55, 57);
						}
						break;
					default:
						if (i1 == 0 || l1 == 0 || i2 == 0 || l2 == 0)
							break;
						else
							break;
					}
				} while (i != startsAt);
			}
			if (kind != 0x7fffffff) {
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7fffffff;
			}
			++curPos;
			if ((i = jjnewStateCnt) == (startsAt = 98 - (jjnewStateCnt = startsAt)))
				return curPos;
			try {
				curChar = input_stream.readChar();
			} catch (java.io.IOException e) {
				return curPos;
			}
		}
	}

	private int jjMoveStringLiteralDfa0_1() {
		switch (curChar) {
		case 42:
			return jjMoveStringLiteralDfa1_1(0x200L);
		default:
			return 1;
		}
	}

	private int jjMoveStringLiteralDfa1_1(long active0) {
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			return 1;
		}
		switch (curChar) {
		case 47:
			if ((active0 & 0x200L) != 0L)
				return jjStopAtPos(1, 9);
			break;
		default:
			return 2;
		}
		return 2;
	}

	static final int[] jjnextStates = { 62, 63, 65, 16, 66, 67, 36, 37, 39, 23, 25, 1, 2, 4, 54, 55, 56, 57, 60, 49, 52, 6, 7, 9, 17, 18, 21, 32, 34, 36, 37,
		41, 39, 36, 37, 43, 39, 45, 47, 36, 37, 46, 39, 50, 51, 56, 57, 60, 64, 18, 21, 73, 75, 82, 84, 86, 87, 89, 86, 87, 91, 89, 86, 87, 93, 89, 95, 97, 86,
		87, 96, 89, 72, 85, 19, 20, 26, 27, 29, 31, 38, 40, 42, 44, 68, 69, 76, 77, 79, 81, 88, 90, 92, 94, };

	private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
		case 0:
			return ((jjbitVec2[i2] & l2) != 0L);
		default:
			if ((jjbitVec0[i1] & l1) != 0L)
				return true;
			return false;
		}
	}

	/** Token literal values. */
	public static final String[] jjstrLiteralImages = { "", null, null, null, null, null, null, null, null, null, null, "\141\142\163\164\162\141\143\164",
		"\145\170\143\145\160\164\151\157\156", "\151\156\157\165\164", "\160\162\157\166\151\144\145\163", "\164\162\165\156\143\141\164\141\142\154\145",
		"\141\156\171", "\145\155\151\164\163", "\151\156\164\145\162\146\141\143\145", "\160\165\142\154\151\143", "\164\171\160\145\144\145\146",
		"\141\164\164\162\151\142\165\164\145", "\145\156\165\155", "\154\157\143\141\154", "\160\165\142\154\151\163\150\145\163", "\164\171\160\145\151\144",
		"\142\157\157\154\145\141\156", "\145\166\145\156\164\164\171\160\145", "\154\157\156\147", "\162\141\151\163\145\163",
		"\164\171\160\145\160\162\145\146\151\170", "\143\141\163\145", "\146\141\143\164\157\162\171", "\155\157\144\165\154\145",
		"\162\145\141\144\157\156\154\171", "\165\156\163\151\147\156\145\144", "\143\150\141\162", "\106\101\114\123\105", "\155\165\154\164\151\160\154\145",
		"\163\145\164\162\141\151\163\145\163", "\165\156\151\157\156", "\143\157\155\160\157\156\145\156\164", "\146\151\156\144\145\162",
		"\156\141\164\151\166\145", "\163\145\161\165\145\156\143\145", "\165\163\145\163", "\143\157\156\163\164", "\146\151\170\145\144",
		"\163\150\157\162\164", "\126\141\154\165\145\102\141\163\145", "\143\157\156\163\165\155\145\163", "\146\154\157\141\164", "\157\143\164\145\164",
		"\163\164\162\151\156\147", "\166\141\154\165\145\164\171\160\145", "\143\157\156\164\145\170\164", "\147\145\164\162\141\151\163\145\163",
		"\157\156\145\167\141\171", "\163\164\162\165\143\164", "\166\157\151\144", "\143\165\163\164\157\155", "\150\157\155\145", "\157\165\164",
		"\163\165\160\160\157\162\164\163", "\167\143\150\141\162", "\144\145\146\141\165\154\164", "\151\155\160\157\162\164",
		"\160\162\151\155\141\162\171\153\145\171", "\163\167\151\164\143\150", "\167\163\164\162\151\156\147", "\144\157\165\142\154\145", "\151\156",
		"\160\162\151\166\141\164\145", "\124\122\125\105", "\117\142\152\145\143\164", "\155\141\156\141\147\145\163", "\73", "\173", "\175", "\72", "\54",
		"\72\72", "\50", "\51", "\75", "\174", "\136", "\46", "\76\76", "\74\74", "\53", "\55", "\52", "\57", "\45", "\176", "\74", "\76", "\133", "\135", null,
		null, null, null, null, null, null, null, null, null, null, };

	protected Token jjFillToken() {
		final Token t;
		final String curTokenImage;
		final int beginLine;
		final int endLine;
		final int beginColumn;
		final int endColumn;
		String im = jjstrLiteralImages[jjmatchedKind];
		curTokenImage = (im == null) ? input_stream.GetImage() : im;
		beginLine = input_stream.getBeginLine();
		beginColumn = input_stream.getBeginColumn();
		endLine = input_stream.getEndLine();
		endColumn = input_stream.getEndColumn();
		t = Token.newToken(jjmatchedKind, curTokenImage);

		t.beginLine = beginLine;
		t.endLine = endLine;
		t.beginColumn = beginColumn;
		t.endColumn = endColumn;

		return t;
	}

	int curLexState = 0;
	int defaultLexState = 0;
	int jjnewStateCnt;
	int jjround;
	int jjmatchedPos;
	int jjmatchedKind;

	/** Get the next Token. */
	public Token getNextToken() {
		Token specialToken = null;
		Token matchedToken;
		int curPos = 0;

		EOFLoop: for (;;) {
			try {
				curChar = input_stream.BeginToken();
			} catch (java.io.IOException e) {
				jjmatchedKind = 0;
				jjmatchedPos = -1;
				matchedToken = jjFillToken();
				matchedToken.specialToken = specialToken;
				CommonTokenAction(matchedToken);
				return matchedToken;
			}
			image = jjimage;
			image.setLength(0);
			jjimageLen = 0;

			for (;;) {
				switch (curLexState) {
				case 0:
					try {
						input_stream.backup(0);
						while (curChar <= 32 && (0x100003600L & (1L << curChar)) != 0L)
							curChar = input_stream.BeginToken();
					} catch (java.io.IOException e1) {
						continue EOFLoop;
					}
					jjmatchedKind = 0x7fffffff;
					jjmatchedPos = 0;
					curPos = jjMoveStringLiteralDfa0_0();
					break;
				case 1:
					jjmatchedKind = 0x7fffffff;
					jjmatchedPos = 0;
					curPos = jjMoveStringLiteralDfa0_1();
					if (jjmatchedPos == 0 && jjmatchedKind > 10) {
						jjmatchedKind = 10;
					}
					break;
				}
				if (jjmatchedKind != 0x7fffffff) {
					if (jjmatchedPos + 1 < curPos)
						input_stream.backup(curPos - jjmatchedPos - 1);
					if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
						matchedToken = jjFillToken();
						matchedToken.specialToken = specialToken;
						if (jjnewLexState[jjmatchedKind] != -1)
							curLexState = jjnewLexState[jjmatchedKind];
						CommonTokenAction(matchedToken);
						return matchedToken;
					} else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
						if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
							matchedToken = jjFillToken();
							if (specialToken == null)
								specialToken = matchedToken;
							else {
								matchedToken.specialToken = specialToken;
								specialToken = (specialToken.next = matchedToken);
							}
							SkipLexicalActions(matchedToken);
						} else
							SkipLexicalActions(null);
						if (jjnewLexState[jjmatchedKind] != -1)
							curLexState = jjnewLexState[jjmatchedKind];
						continue EOFLoop;
					}
					jjimageLen += jjmatchedPos + 1;
					if (jjnewLexState[jjmatchedKind] != -1)
						curLexState = jjnewLexState[jjmatchedKind];
					curPos = 0;
					jjmatchedKind = 0x7fffffff;
					try {
						curChar = input_stream.readChar();
						continue;
					} catch (java.io.IOException e1) {
					}
				}
				int error_line = input_stream.getEndLine();
				int error_column = input_stream.getEndColumn();
				String error_after = null;
				boolean EOFSeen = false;
				try {
					input_stream.readChar();
					input_stream.backup(1);
				} catch (java.io.IOException e1) {
					EOFSeen = true;
					error_after = curPos <= 1 ? "" : input_stream.GetImage();
					if (curChar == '\n' || curChar == '\r') {
						error_line++;
						error_column = 0;
					} else
						error_column++;
				}
				if (!EOFSeen) {
					input_stream.backup(1);
					error_after = curPos <= 1 ? "" : input_stream.GetImage();
				}
				throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
			}
		}
	}

	void SkipLexicalActions(Token matchedToken) {
		switch (jjmatchedKind) {
		default:
			break;
		}
	}

	private void jjCheckNAdd(int state) {
		if (jjrounds[state] != jjround) {
			jjstateSet[jjnewStateCnt++] = state;
			jjrounds[state] = jjround;
		}
	}

	private void jjAddStates(int start, int end) {
		do {
			jjstateSet[jjnewStateCnt++] = jjnextStates[start];
		} while (start++ != end);
	}

	private void jjCheckNAddTwoStates(int state1, int state2) {
		jjCheckNAdd(state1);
		jjCheckNAdd(state2);
	}

	private void jjCheckNAddStates(int start, int end) {
		do {
			jjCheckNAdd(jjnextStates[start]);
		} while (start++ != end);
	}

	/** Constructor. */
	public IDLParserTokenManager(JavaCharStream stream) {

		if (JavaCharStream.staticFlag)
			throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");

		input_stream = stream;
	}

	/** Constructor. */
	public IDLParserTokenManager(JavaCharStream stream, int lexState) {
		ReInit(stream);
		SwitchTo(lexState);
	}

	/** Reinitialise parser. */
	public void ReInit(JavaCharStream stream) {
		jjmatchedPos = jjnewStateCnt = 0;
		curLexState = defaultLexState;
		input_stream = stream;
		ReInitRounds();
	}

	private void ReInitRounds() {
		int i;
		jjround = 0x80000001;
		for (i = 98; i-- > 0;)
			jjrounds[i] = 0x80000000;
	}

	/** Reinitialise parser. */
	public void ReInit(JavaCharStream stream, int lexState) {
		ReInit(stream);
		SwitchTo(lexState);
	}

	/** Switch to specified lex state. */
	public void SwitchTo(int lexState) {
		if (lexState >= 2 || lexState < 0)
			throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
		else
			curLexState = lexState;
	}

	/** Lexer state names. */
	public static final String[] lexStateNames = { "DEFAULT", "IN_MULTI_LINE_COMMENT", };

	/** Lex State array. */
	public static final int[] jjnewLexState = { -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, };
	static final long[] jjtoToken = { 0xfffffffffffff801L, 0x7fffffffffffL, };
	static final long[] jjtoSkip = { 0x2feL, 0x0L, };
	static final long[] jjtoSpecial = { 0x2c0L, 0x0L, };
	static final long[] jjtoMore = { 0x500L, 0x0L, };
	protected JavaCharStream input_stream;

	private final int[] jjrounds = new int[98];
	private final int[] jjstateSet = new int[2 * 98];

	private final StringBuilder jjimage = new StringBuilder();
	private StringBuilder image = jjimage;
	private int jjimageLen;
	private int lengthOfMatch;

	protected char curChar;
}
